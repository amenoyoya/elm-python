# エラーハンドリング

## データとしてのエラー

Elmはエラーをデータとして扱うため、ランタイムエラーというものが実行中に起こることはあり得ない

アプリケーション開発においては、エラーが起こってアプリケーション全体がクラッシュするよりは、失敗の可能性を明示的にカスタム型で定義する方が好まれる

例えば、ユーザーからの入力を年齢に変換したい場合、以下のように表現すると上手に処理される

```elm
{- MaybeAgeカスタム型
    - Int型関連データを持つAgeバリアント
    - InvalidInputバリアント（無効な入力用の型を明示）
-}
type MaybeAge = Age Int | InvalidInput

-- StringをMaybeInputに変換する関数
toAge : String -> MaybeInput
toAge userInput =
  {- userInputをString.toInt関数に渡してパターンマッチング
    String.toInt : String -> Maybe Int
        - Just Int: Int型に変換出来たら Age Intバリアントを返す
        - Nothing: Int型に変換出来なかったら InvalidInputバリアントを返す
  -}
  case (String.toInt userInput) of
    Just integer -> Age integer
    Nothing -> InvalidInput

-- 動作確認
toAge "18"
--> Age 18 : MaybeAge

toAge "hello"
--> InvalidInput : MaybeAge
```

### Maybe
上記のプログラムで少し出てきたが、ElmではMaybe型を頻繁に見る

Maybe型は、「何も持っていない（`Nothing`）」か、「ちょうど（`Just`）の1つの値を持っている」という2つのバリアントを持つカスタム型で、以下のように定義されている

```elm
-- 定義 --
type Maybe a = Just a | Nothing

-- 例 --
Just 3.14
--> Just 3.14 : Maybe Float

Just "hello"
--> Just "hello" : Maybe String

Nothing
--> Nothing : Maybe a
```

Maybe型は以下のような場面でよく使われる

- **部分関数**
    - ある入力に対しては答えを与えるが、他には与えない関数
    - 例えば、前述した`toAge`関数のようなもの
- **入力が任意のフィールド**
    - 例えば、フォームの任意項目などに対応したフィールド

#### 使いすぎを避ける
Maybe型は便利だが、多用するとアプリケーションの動作を正確にモデリングできないことがある

例えば、以下のような仕様のエクササイズアプリを作るとする

- 友達のフィットネス情報を保持
    - 名前: 必須
    - 年齢: 任意
    - 身長: 任意
    - 体重: 任意
- 最初に友達の名前のリストを取ってきておく
- 必要になったら、名前からその友達のフィットネス情報をロードする
- フィットネス情報を比較し、競争する

このような場合、すぐに思いつく実装は以下のようなものである

```elm
type alias Friend = {
    name : String,
    age : Maybe Int,
    height : Maybe Float,
    weight : Maybe Float
}
```

上記の実装は、必要な情報を表現できてはいるが、アプリケーションの動作を正確にはモデリングできていない

今回のアプリケーションにおいてあり得る状況は、

- Less: 名前のみ表示
- More: 名前と{年齢, 身長, 体重}をすべて表示

従って、以下のように実装するのがより正確といえる

```elm
type Friend
  = Less String
  | More String Info

type alias Info = {
    age : Int,
    height : Float,
    weight : Float
}
```

より正確な表現を見つけるためには、`Maybe`の代わりに`type`, `type alias`を使った定義ができないか調べてみる必要がある

#### null参照との比較
null参照による設計は、失敗を**暗黙的**にしてしまう

そこにStringがあると思っていても、実際には null を参照している可能性を捨てることができない

null参照は、その確認を行わなければならないタイミングを曖昧にしてしまう

一方で、Maybeのようなカスタム型は、失敗を**明示的**に表現する

String型があれば、それは紛れもなくStringであり、失敗していないことはコンパイラが保証してくれる

また、 Maybe String があれば、StringとNothingの両方のバリアントが適切に処理されていることが保証される

これにより、null参照と同じ柔軟性を実現しつつ、突然クラッシュするような設計からアプリケーションを保護できるようにあった